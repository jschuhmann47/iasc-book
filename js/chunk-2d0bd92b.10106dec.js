(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0bd92b"],{"2d25":function(e,a,s){"use strict";s.r(a);var r=function(){var e=this,a=e.$createElement;e._self._c;return e._m(0)},n=[function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("section",[s("h2",{attrs:{id:"paradigma-funcional-qué-es-eso"}},[e._v("¿Paradigma Funcional? ¿Qué es eso? "),s("a",{staticClass:"header-anchor",attrs:{href:"#paradigma-funcional-qué-es-eso"}},[e._v("¶")])]),s("p",[e._v("Es irónico que aunque el paradigma funcional es muy anterior al paradigma de objetos, lo que le ha dado la posibilidad de construir sólidas bases, es difícil dar una definición del mismo. Por ejemplo, la definición más obvia reza que funcional es un paradigma en el que las soluciones a los problemas se estructuran en términos de aplicación de funciones y, si bien es correcta, hay tantos elementos fundamentales que se desprenden de ésta y que no son evidentes que resulta de poca utilidad.")]),s("p",[e._v("Quizás sea más útil pensarlo a partir de las características más frecuentemente evocadas cuando se piensa en éste:")]),s("ul",[s("li",[e._v("Pureza: las funciones, al igual que en matemática, no presentan efectos colaterales, sino que tan sólo reciben, operan y devuelven valores")]),s("li",[e._v("Evaluación diferida: ciertas partes del código no se evaluarán salvo que sea necesario")]),s("li",[e._v("Funciones de primer orden: las funciones son valores, y por tanto pueden ser pasadas por parámetro")]),s("li",[e._v("Pattern matching: los valores pueden ser descompuestos estructuralmente, en un proceso inverso a la construcción: la deconstrucción. Y además podemos usar a esta herramienta como mecanismo de control de flujo: según encaje un valor con un patrón u otro, podremos tomar acciones diferentes.")]),s("li",[e._v("Expresiones lambda: Es posible escribir valores de función de forma literal, sin asignarle un nombre.")]),s("li",[e._v("Inmutabilidad: las variables son meras etiquetas, que una vez unificadas contra un valor, no pueden ser cambiadas.")])]),s("p",[e._v("Sin embargo, ¿son las anteriores ideas propias del paradigma funcional? Miremos más en detalle:")]),s("ul",[s("li",[e._v("No todos los lenguajes funcionales son realmente puros. LISP y sus derivados, por ejemplo, no lo son normalmente: permiten hacer input-ouput (IO) imperativo, modificar variables, etc.")]),s("li",[e._v("No todos los lenguajes funcionales presentan evaluación diferida. Para ser justos, ni siquiera Haskell: éste ofrece evaluación no-estricta, lo cual es ligeramente diferente.")])]),s("p",[e._v("Por un lado muchos lenguajes (funcionales o no) presentan algún tipo de operación de deconstrucción: Ruby, ECMAScript6, Clojure, etc, que es la base para implementar pattern-matching. Y por otro lado, la idea de Pattern matching no figura en Cálculo Lambda, la base teórica de funcional.")]),s("p",[e._v("Virtualmente todos los lenguajes modernos presentan lambdas, closures o bloques de código, que permiten cosificar una porción de código.")]),s("p",[e._v("Si nada de lo que parece tan propio de funcional es realmente exclusivo del mismo, entonces, volvemos a la pregunta: ¿qué es eso? Simple: es la forma particular en que combinamos estas herramientas, razonando declarativamente en términos de valores y transformaciones sobre los mismos. Nuevamente, el todo es más que la suma de las partes.")]),s("p",[e._v("Durante las próximas clases vamos a estar viendo por qué el paradigma funcional puede ser una herramienta muy útil a la hora de trabajar con concurrencia y paralelismo. En particular, vamos a estar trabajando con Haskell, uno de los exponentes más notables de este paradigma. Pero antes, vamos a necesitar aprender (o repasar) algunos conceptos que nos van a ser de utilidad más adelante.")]),s("h2",{attrs:{id:"sobre-pureza-en-funcional"}},[e._v("Sobre pureza en funcional "),s("a",{staticClass:"header-anchor",attrs:{href:"#sobre-pureza-en-funcional"}},[e._v("¶")])]),s("p",[e._v("Haskell es un lenguaje puro; toda operación es similar a una función matemática, donde el resultado de dicha función depende únicamente de sus argumentos. Tanto es así, que hasta los efectos están modelados como valores de tipo IO, que representa un efecto, el cual puede ser operado como cualquier otro valor: podemos pasar efectos por parámetros, colocarlos en listas, ordenarlos, etc. De hecho, un programa ejecutable es una función que devuelve un valor de tipo IO. El runtime de Haskell ejecuta el efecto representado por este valor, produciendo así los efectos en el mundo real deseados. Moraleja: un programa Haskell no tiene efectos, pero es capaz de devolver un valor que los representa, pudiendo así hacer todo lo que un programa imperativo podría hacer, y más.")]),s("h2",{attrs:{id:"simplicidad"}},[e._v("Simplicidad "),s("a",{staticClass:"header-anchor",attrs:{href:"#simplicidad"}},[e._v("¶")])]),s("p",[e._v("La sintaxis e ideas fundamentales de Haskell son realmente simples, y el resto de las ideas más complejas se construyen normalmente sobre las más simples.")]),s("p",[s("strong",[e._v("TODO: Completar o eliminar sección.")])]),s("h2",{attrs:{id:"tipos-en-haskell"}},[e._v("Tipos en Haskell "),s("a",{staticClass:"header-anchor",attrs:{href:"#tipos-en-haskell"}},[e._v("¶")])]),s("p",[e._v("A diferencia de otros lenguajes, como Ruby o Smalltalk, Haskell tiene un sistema de tipos estático. Esto significa que el tipo de cada expresión es conocido en tiempo de compilación.")]),s("p",[e._v("Ilustrémoslo con un ejemplo: si tenemos una función que suma dos números, y le pasamos un string que se sume a un int, en un lenguaje dinámico solo fallaría en tiempo de ejecución, mientras que en un lenguaje con un sistema de tipos estático, no compilaría. Esto permite que puedan capturarse errores en tiempo de compilación en vez de que tengan que aparecer en ejecución.")]),s("p",[e._v("En Haskell todo tiene un tipo, y a diferencia de otros lenguajes similares como Java, Haskell tiene además inferencia de tipos. Si escribimos un número, no tenemos que decirle a Haskell que es un número, sino que puede inferirlo solo. El tipo de un valor se puede conocer por medio del comando "),s("code",{pre:!0},[e._v(":t")]),e._v(":")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-haskell"}},[s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> :t 'a'\n'a' :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Char")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> :t "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("True")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("True")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Bool")]),e._v("\n")])]),s("p",[e._v("Como vemos en el GhCI, cuando ejecutamos el comando "),s("code",{pre:!0},[e._v(":t")]),e._v(" junto con un valor, nos dice de qué tipo es. "),s("code",{pre:!0},[e._v("x :: T")]),e._v(' puede leerse como "x es del tipo T".')]),s("p",[e._v("Con expresiones más complejas podemos ver algo como lo siguiente:")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-haskell"}},[s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> :t "),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("4")]),e._v(" + "),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("3")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("4")]),e._v(" + "),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("3")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Num")]),e._v(" a => a\n")])]),s("p",[e._v("Simple, todas las expresiones generan un valor con un tipo asociado.")]),s("p",[e._v("Las funciones son otra cosa que también necesita una declaración de tipos, y es una buena práctica que ayuda al sistema de inferencia de tipos, y es recomendado a menos que se necesite crear funciones muy chicas. Empecemos con un ejemplo bien simple:")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-haskell"}},[s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("let")]),e._v(" succ a = a + "),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> :t succ\n"),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("succ")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Num")]),e._v(" a => a -> a \n")])]),s("p",[e._v("Esto se vería así en un código que no sea ghci")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-haskell"}},[s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("succ")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Int")]),e._v(" -> "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Int")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("succ")]),e._v(" a = a + "),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v("\n")])]),s("p",[e._v("Veamos un poco más en detalle otro prototipo de función, por ej. "),s("code",{pre:!0},[e._v("head")]),e._v(" y "),s("code",{pre:!0},[e._v("tail")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-haskell"}},[s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> :t head\n"),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("head")]),e._v(" :: [a] -> a\n\n"),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> :t tail\n"),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("tail")]),e._v(" :: [a] -> [a]\n")])]),s("p",[e._v("Este ejemplo es bien conocido por tomar el primer elemento de una lista, head. Pero veamos la declaración de tipos, head toma un parámetro, que es del tipo lista de a. Pero a no es un tipo... ¿qué es entonces? En este caso es un tipo genérico. Puede ser un "),s("code",{pre:!0},[e._v("Int")]),e._v(", "),s("code",{pre:!0},[e._v("String")]),e._v(", etc., pero el tipo va a ser consistente; es decir, si tenemos una función que va de "),s("code",{pre:!0},[e._v("[a] -> a")]),e._v(", entonces si a es un "),s("code",{pre:!0},[e._v("Int")]),e._v(", la función va a tomar una lista de "),s("code",{pre:!0},[e._v("Int")]),e._v(", y devolver un "),s("code",{pre:!0},[e._v("Int")]),e._v(". Esto es porque la función es polimórfica y puede tomar cualquier lista de un tipo, y devolver el primer elemento, sin importar de qué tipo es la lista.")]),s("p",[e._v("Nuestra función "),s("code",{pre:!0},[e._v("succ")]),e._v(", en cambio, solo toma un "),s("code",{pre:!0},[e._v("Int")]),e._v(" y devuelve otro "),s("code",{pre:!0},[e._v("Int")]),e._v(". Si le pasamos algo de tipo "),s("code",{pre:!0},[e._v("String")]),e._v(", fallaría en tiempo de compilación.")]),s("p",[e._v("En el ejemplo de "),s("code",{pre:!0},[e._v("head")]),e._v(", en la declaración de tipos, a es llamado type variable.")]),s("p",[e._v("Tomemos otro ejemplo, "),s("code",{pre:!0},[e._v("fst")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-haskell"}},[s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> :t fst\n"),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("fst")]),e._v(" :: (a, b) -> a\n")])]),s("p",[e._v("En este caso se puede ver cómo la función toma una tupla y devuelve el primer elemento, y tenemos dos type variables, a y b, que si bien son diferentes, no significa que sean de tipos distintos. También podemos ver que el primer elemento y lo que devuelve la función son del mismo tipo, tal como ocurre con "),s("code",{pre:!0},[e._v("head")]),e._v(".")]),s("h2",{attrs:{id:"typeclases"}},[e._v("Typeclases "),s("a",{staticClass:"header-anchor",attrs:{href:"#typeclases"}},[e._v("¶")])]),s("p",[e._v("Una Typeclass es como una especie de interfaz que define un comportamiento. Si un tipo es parte de una typeclass, el tipo soporta e implementa el comportamiento que describe dicha typeclass. Haciendo una comparación con el paradigma de objetos, podríamos decir que las typeclases son como las interfaces de Java, pero implementando el comportamiento, no solo definiendo su contrato.")]),s("p",[e._v("Veamos la operación suma de "),s("code",{pre:!0},[e._v("succ")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-haskell"}},[s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> :t (+)\n(+) :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Num")]),e._v(" a => a -> a -> a\n")])]),s("p",[e._v("Antes que nada vemos que ahora está el símbolo "),s("code",{pre:!0},[e._v("=>")]),e._v(". La lectura hacia la derecha es como las funciones que vimos hasta ahora: la función toma dos elementos de tipo a y devuelve otro de tipo a. A la izquierda del "),s("code",{pre:!0},[e._v("=>")]),e._v(" se indica que el tipo de los dos valores y el retorno deben ser miembros de la clase "),s("code",{pre:!0},[e._v("Num")]),e._v(". Esto último se conoce como "),s("strong",[e._v("class constraint")]),e._v(".")]),s("p",[e._v("Veamos otro ejemplo")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-haskell"}},[s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> :t (<=)\n(<=) :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Ord")]),e._v(" a => a -> a -> "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Bool")]),e._v("\n")])]),s("p",[s("code",{pre:!0},[e._v("Ord")]),e._v(" es otra typeclass, que define la interfaz para ordenamiento (<, >, <= y >=, entre otras), por lo que cualquier tipo que requiera ordenamiento de dos o más elementos, debe ser un miembro de "),s("code",{pre:!0},[e._v("Ord")]),e._v(".")]),s("p",[e._v("Volviendo a la suma, vimos que "),s("code",{pre:!0},[e._v("Num")]),e._v(" es un typeclass numérico, y permite que un tipo actúe como número, por ej:")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-haskell"}},[s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> :t "),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("42")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("42")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Num")]),e._v(" a => a\n")])]),s("p",[e._v("Por lo que los números pueden actuar como constantes polimórficas, por lo que podemos definir un 42 numérico, flotante o doble, pero hay operaciones que si bien son parte del typeclass, su contrato debe ser cumplido, por ej. si sumamos un doble con un interfaces")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-haskell"}},[s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> ("),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("42")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Integer")]),e._v(") + ("),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("2")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Double")]),e._v(")\n\n<interactive>:"),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("25")]),e._v(":"),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("20")]),e._v(":\n    "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Couldn't")]),e._v(" match expected "),s("span",{pre:!0,attrs:{class:"hljs-class"}},[s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("type")]),e._v(" ‘"),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Integer")]),e._v("’ with actual "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("type")]),e._v(" ‘"),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Double")]),e._v("’")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("In")]),e._v(" the second argument "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("of")]),e._v(" ‘(+)’, namely ‘("),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("2")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Double")]),e._v(")’\n    "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("In")]),e._v(" the expression: ("),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("42")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Integer")]),e._v(") + ("),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("2")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Double")]),e._v(")\n    "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("In")]),e._v(" an equation for ‘it’: it = ("),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("42")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Integer")]),e._v(") + ("),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("2")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Double")]),e._v(")\n"),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Prelude")]),e._v("> ("),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("42")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Integer")]),e._v(") + ("),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("2")]),e._v(" :: "),s("span",{pre:!0,attrs:{class:"hljs-type"}},[e._v("Integer")]),e._v(")\n"),s("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("44")]),e._v("\n")])]),s("h2",{attrs:{id:"dualidad-en-estructuras-de-tipos"}},[e._v("Dualidad en estructuras de tipos "),s("a",{staticClass:"header-anchor",attrs:{href:"#dualidad-en-estructuras-de-tipos"}},[e._v("¶")])]),s("p",[e._v("Cada una de ellas presenta una dualidad, pudiendo ser pensada tanto como una estructura de datos, como una estructura de control. Dicho de otra forma, a las estructuras funcionales podemos verlas tanto como contenedores (cajas que almacenan valores) como computaciones (operaciones que al ejecutarlas producen valores).")])])}],o=s("2877"),t={},l=Object(o["a"])(t,r,n,!1,null,null,null);a["default"]=l.exports}}]);
//# sourceMappingURL=chunk-2d0bd92b.10106dec.js.map